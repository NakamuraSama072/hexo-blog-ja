[{"title":"2025-8-18 v2.0 Changelog","url":"/2025/08/18/changelog2/","content":"長期間にわたる改修を経て、このブログサイトがついに 2.0 バージョンにアップデートされました。\n以下に具体的な説明を記載します。\n新機能&#x2F;What’s New新機能&#x2F;New Features\n「概要」ページを追加しました\n\n\n\n関連記事の推薦セクションを追加しました\n\n\n\n英語と日本語のポータルサイトを追加（注：英語サイトは、中国語と日本語のサイトと異なるテーマを使用しています）\n\n\n\n注意：v1.0バージョン時点では、日本語サイトは既に展開されていましたが、当時はまだテスト段階にありました。\n変更点&#x2F;Changed\nサイトの美化と国際化対応のため、ブログのテーマを Redefine 2.8.5 から Butterfly 5.4.3 に変更しました\n\n\n修正内容&#x2F;Bug Fix\n特定の記事内に存在していた誤った内容を修正しました\nGit コミット時に変更内容がデプロイ先のウェブサイトに表示されない問題を修正しました\n新テーマ使用時に「友達」ページが開けない問題を修正しました\n\n国際化についてここで採用した方法は、言語ごとに異なるリポジトリを使用し、最終的にドロップダウンメニューのリンクで遷移させるものです。これは最善策ではありませんが、source フォルダのコンテンツをいじくり回して大量の JavaScript を追加するよりもはるかに優れています。もう一つの大きな利点は、言語ごとに異なる地域向けのテーマを指定できることで、これにより異なる国や地域（例えば欧米）の人々の好みに合わせやすくなります。\n","categories":["changelog"],"tags":["changelog"]},{"title":"2025-8-9 v1.0 Changelog","url":"/2025/08/09/first-blog/","content":"これは自サイト開設以来の最初のブログ記事です。サイト構築プロセスは大変で、途中で何度もトラブルが発生したため、ここではサイトの内容と遭遇した困難について簡単に説明し、一時的なサイトテストとして扱います。\n以降、各メジャーバージョンの更新後は、新機能、バグ修正、および詳細な最適化を説明する Changelog を公開します。\n新機能&#x2F;What’s New新機能&#x2F;New Features\nHexo 7.3.0 でブログのフレームワークを構築し、Redefine 2.8.5 をテーマとして使用しています。\n\n\n\n「カテゴリ」「リンク集」「タグ」ページを追加し、ブログコンテンツの検索や参照する他のブログサイトのリスト表示を容易にしました。句読点について聞かないでください\n\n\nバグ修正&#x2F;Bug Fix\nFirefox でのウェブページレンダリング異常エラーを修正しました\n\n「リンク」サブメニュー内でリンクを開いた際に 404 エラーが表示される問題を修正\n\n\nブログについてこのブログは何のためのものですか？ウェブサイトの上部バナーに表示されているように、「Linux and You」。したがって、このブログは主に Linux に関する内容を中心に、C/C++ や Python などの記事も含まれる可能性があります。\nこのブログはどのように構築したのですか？最初は ClawCloud のクラウドサービスを利用していました（価格が非常に魅力的だったため、Github の既存ユーザーには $5 の無料クレジットが付与されるため）。しかし、2日後、ブログファイルが格納されているポッドが常に Pending 状態になり、再起動を何度試しても改善されなかったため、怒りに任せてすべてのリソースを削除しました。\n複数のクラウドサービスプロバイダーを比較した結果、Azure と AWS は費用が高額で、インターフェースも操作が難しいことが分かりました。Google は費用が比較的低額ですが、潜在的なプライバシー問題があります。\n最終的に、Github を検討することにしました。Vercel が一部の地域でアクセス禁止されているため、Github と Netlify を組み合わせた方法でデプロイし、現在まで特に問題はありません。\nウェブサイト構築時に遭遇した問題は何ですか？「エラー修正」と上記で述べた問題の他に、以下の問題が発生しました：\n\nブランチの入力ミス。初期ブランチは main でしたが、私は master と間違えて入力しました（後に削除しました）。これにより、VSCode 内の Git の master ブランチが幽霊のように消えず、最終的にリポジトリを削除して最初からやり直す羽目になりました。（幸い、まだ設定は行っていませんでした）\n\n中日韩文字の文字化けやレンダリング異常。調べた結果、VSCode が GBK ではなく UTF-8 エンコードを使用していたためでした。\n\n\nその他の minor な問題や不可抗力要因（例えば授業など）は、ここでは詳細に説明しません。\nブログはどのような更新計画を採用するのでしょうか？ブログは Debian や Ubuntu のような安定版更新戦略を採用し、ロールイング更新は行いません。ロールイング更新を採用した場合、以下の問題が発生する可能性があります：\n\nGit のコミットが過度に頻繁になり、バージョン履歴が混乱し、管理が困難になります。\n\n新バージョンの機能決定が困難。継続的な小規模更新では明確な段階的目標が欠如する可能性があります。\n\n時間問題。頻繁な更新はメンテナンスコストを増大させますが、安定版は更新ペースとコンテンツ品質のバランスを適切に保てます。\n\n\nしたがって、ブログは不定期（ローリング更新のような頻度ではなく）にテスト済みで完成されたバージョンをリリースし、各更新で安定した体験を提供します。\nブログ内の記事には、注意や説明のセクションはありますか？あります。内容の程度に応じて、以下の3種類に分類されます：\n\n説明&#x2F;ヒント\n\n現在の内容に対する補足説明または関連情報のヒントを示します。\nCinnamon デスクトップ環境は、実際は GNOME 3 の分岐です。\n\n\n\n注意\n\n現在の環境下で推奨（強制ではない）される操作、または注意が必要な事項を示します。\nC&#x2F;C++ コンパイラは実行時チェックを行わないため、配列の越境やスタックオーバーフローなどの問題が発生するとプログラムが強制終了します。\n\n\n\n禁止\n\n現在の環境下で必須（強制）または絶対禁止の操作、または特定の操作がシステムやハードウェアに不可逆な損害を引き起こす可能性があることを示します。\n場合によっては、この部分のコンテンツがまだ作成中であり、一時的にアクセスできないことを示すためにも使用されます。\nハードディスクのフォーマットは、対象のハードディスク上のすべてのパーティションのデータを消去します！！\n\n\n以降の新しい機能\n 「概要」ページを追加\n 底部におすすめ記事セクションを追加し、迅速な移動を可能に\n ナビゲーションバーの内容を再整理\n コメント機能を追加 （現在計画なし）\n\n","categories":["changelog"],"tags":["changelog"]},{"title":"Debian 13 アップグレードガイド","url":"/2025/08/11/debian-13/","content":"This site is translated by DeepL and might not have the original taste of Japanese.\n\n\n2025年8月9日、待望の Debian 13 Trixie がついに「待望のデビュー」を果たしました。6.12 LTS カーネル、GNOME 48、そしてほぼ最新バージョンに更新されたソフトウェアパッケージを携えて登場しました。これにより、Debian は安定性における従来の評判を維持しつつ、ハードウェアサポート、パフォーマンス最適化、デスクトップ体験の面で大きな進歩を遂げました。多くの開発者、サーバー管理者、デスクトップユーザーにとって、今回のアップグレードはより良いハードウェア互換性、より長いセキュリティメンテナンス期間、そして新たな機能の探索が可能になることを意味します。\nこの記事では、Debian 12 Bookworm から Debian 13 Trixie へのスムーズなアップグレード方法について詳細に解説し、新機能を楽しむ一方でリスクを最小限に抑えるためのポイントを説明します。\n前提条件アップグレードを行う前に、現在のシステムが以下の条件を満たしていることを確認してください：\n\n最低 5 GB の空きハードディスク容量\n少なくとも 512 MB のメモリ\namd64 や arm64 など、公式にサポートされているアーキテクチャの CPU\n安定したネットワーク接続\n\nDebian 12 をまだインストールしていない場合は、この記事をスキップして直接 Debian 13 をインストールしてください。\n\nDebian 13 Trixie 以降、i386（32ビット）アーキテクチャは公式にサポートされなくなりました。i386 アーキテクチャを継続して使用する必要があるユーザーは、他の i386 をサポートする Linux ディストリビューションを使用するか、今後のアップグレードを行わないことを検討してください。\n\nアップグレードプロセス全体はカーネルの更新を含むため、更新プロセスが中断されるとシステムが起動できなくなったり、正常に動作しなくなったりする可能性があります。また、システムのスリープ機能を必ず無効化してください。そうしないと、更新が不完全になったり、直接中断されたりする可能性があります。\n\n更新を行う前に、サーバーとのネットワーク接続が正常であることを確認してください。無線ネットワークの品質が非常に悪い場合は、別の場所に移って再度試してください。条件が許す場合は、イーサネットまたは有線接続の使用を推奨します。以下のコマンドを使用して、サーバーとの接続性をテストできます：\n\n\nping www.debian.org # Ctrl + C を押して中止\n\nアップグレード前の準備重要なデータのバックアップ（任意）このステップでは、rsync、tar、または BorgBackup などのツールを使用する必要があります。もちろん、ext4 ファイルシステムを使用している場合は、timeshift も利用可能です。具体的な操作手順については、公式マニュアルをご参照ください。\nソフトウェアソースの更新sudo apt update を実行してソフトウェアソースを更新し、新しいソフトウェアバージョンを取得します。\nDebian 13 以降、ソフトウェアソース設定ファイルは新しい DEB822 形式に全面的に移行され、パスが元の /etc/apt/sources.list から /etc/apt/sources.list.d/debian.sources に変更されます。この変更は、皆様がご存知の Ubuntu 24.04 LTS 以降のバージョンで既に実施されています。\n\n\n\nDebian 12 は以下のコマンドをネイティブでサポートしていません：sudo apt modernize-sourcesDebian 12 でこのコマンドを使用してソフトウェアソース設定ファイルのフォーマットを変更するよう指示するチュートリアルは、誤った情報を提供するものです！\n\n\nこの操作が完了した後、以下のエラーメッセージが表示された場合：\n\nこれは、現在の Debian 12 のソフトウェアソース設定ファイルがまだ Bookworm のものを使用していることを示しています（ソフトウェアソースリポジトリから返される情報によると、Bookworm は現在旧安定版となっていますが、システムは依然としてそれを現在の安定版と認識しています）。この問題を解決するには、sed を使用してテキストを自動的に置換する必要があります（sudo 権限が必要です）：\nsed -i 『s/bookworm/trixie/g』 /etc/apt/sources.list# DEB822 形式の構成ファイルを使用している場合sed -i 『s/bookworm/trixie/g』 /etc/apt/sources.list.d/*.listsed -i 『s/bookworm/trixie/g』 /etc/apt/sources.list.d/*.sources\n後者の2つの提示 no matches found: xxx は、一時的に置き換える必要はありません。\n\n\nこの手順では、/etc/apt/sources.list、/etc/apt/sources.list.d/*.list、および /etc/apt/sources.list.d/*.sources 設定ファイル内の bookworm に一致するすべての文字列を trixie に置き換えます。これにより、現在のバージョンのソフトウェアリポジトリを使用できるようになります。\n別の方法は手動編集です：\nsudo apt edit-sources\n\nこの手順は、vim や nano などのファイルエディターを使用して行うことも可能です。\n事前に伝統的な設定ファイルを新しい DEB822 形式に手動で置き換えた場合、/etc/apt/sources.list を安全に削除できます。\n\n\nシステム更新一部のソフトウェアパッケージのアップグレード新しいソフトウェアパッケージをインストールせずに、一部のソフトウェアパッケージをアップグレードします：\nsudo apt updatesudo apt upgrade --without-new-pkgs\n\nこの手順ではLinuxカーネルのバージョンは更新されません（Debian 12のデフォルトカーネルバージョンがどれほど古いかに注目してください）。この目的は、依存関係の問題を確認するためです。問題がある場合は、sudo apt --fix-broken installを実行して迅速に解決してください。\n\n\nカーネルのアップグレード次に、システム全体を大規模にアップグレードします：\nsudo apt full-upgrade -y\n\nこのステップではカーネルのアップグレードが必要のため、時間がかかりますので、一時的に休憩を取っても構いません。\nアップグレード中に以下の画面が表示される場合があります：\n\nここではYesを選択し、更新プロセスを続行します。\n更新後の操作不要なパッケージの削除ターミナルがaptの情報を表示しなくなり（コマンド入力を待つ状態になる）、ソフトウェアソースをクリーンアップし、不要なパッケージを削除します：\nsudo apt autoremove -y # 不要なパッケージを削除（--purgeオプションを追加可）sudo apt autoclean # ソフトウェアソースをクリーンアップ\n\n現在の更新後のバージョンを確認するカーネルバージョンとシステムバージョンを確認してください：\nuname -r # カーネルバージョンlsb_release -a # システムバージョン# または cat /etc/os-release を実行\n\n出力は以下のようなものになるはずです：\n\n新バージョンを体験開始システムを再起動します：\nsudo reboot\n\nインターフェースのテーマは以下のような画像と類似しているはずです：\n\n\n（リソース節約のため、Xfce デスクトップ環境を使用しています）\nこれで、Debian 13 Trixie へのアップグレード作業は正式に完了しました。\n次期 Debian 安定版についてDebian 14 のコードネームは正式に「forky」と決定されましたが、現在、採用される LTS カーネルやソフトウェアパッケージのバージョンなどに関する詳細は不明です。ただし、以下の点は確定しています：\n\nLTS 戦略の継続\n\n以前のバージョン同様、Debian 14 は少なくとも5年間のセキュリティ更新サイクルを提供し、さらにハードウェア互換性を向上させるため、新しいカーネルのマイナーバージョンを導入する可能性があります。\n\n新しいハードウェアアーキテクチャのサポート\n\n次世代の x86_64-v3 命令セットや ARM プラットフォーム上の最新 SoC に対するサポートを強化し、デスクトップとサーバー機器のパフォーマンス向上を実現します。\n\nデスクトップ環境のバージョンアップグレード\n\nGNOME、KDE Plasma、Xfce などの主要なデスクトップ環境は、上流の主要バージョンに追随し、新しい機能とインターフェースの改善をもたらします。  \n\nソフトウェアパッケージの整理と置き換え\n\nメンテナンスが終了したまたはセキュリティリスクの高いソフトウェアパッケージは削除され、より現代的な代替案が導入されます。\n\nインストールと設定体験の最適化\n\nCalamares、Debian Installer などのインストールツールはさらに改善されます（現在、教育版、天文版など他のバージョンが追加されています）。これにより、新規ユーザーのインストール障壁を低下させ、ユーザー層の多様化を促進します。\n参考https://fullmetalbrackets.com/blog/upgrade-debian-12-bookworm-debian-13-trixie/\nhttps://stackoverflow.com/questions/68802802/repository-http-security-debian-org-debian-security-buster-updates-inrelease\n（元の言語は英語です。可能な場合は、自動翻訳をご利用ください）\n","categories":["Linux","Debian"],"tags":["Linux","Debian"]},{"title":"gtkmm チュートリアル（1）── gtkmm のインストールと使い方","url":"/2025/08/23/gtkmm-note1-installation/","content":"GTK は、GNOME 公式が提供する GNOME デスクトップ環境アプリケーション開発キットです。イベント駆動型に基づいており、実行時にはアプリケーション内で発生するイベント（マウスクリックやウィンドウサイズ変更など）を監視し、アプリケーション内のコンポーネントに情報を伝達します。\nGTK は C、JavaScript、Python、Rust など複数の言語をサポートしています。しかし、ウェブ上で公開されているサンプルコードを見ると、私が比較的慣れ親しんでいる C 言語の実装は複雑であり、Python は比較的シンプルですが、本稿で扱う範囲ではありません。そこで、ここでは構文スタイルが C++ に近い拡張パッケージである gtkmm を、このシリーズの開発ツールキットとして採用します。\n始める前に本シリーズで使用するデフォルトの開発環境は以下の通りです：\n\n\n\n名前\nバージョン\n\n\n\nManjaro\n25\n\n\ngtkmm\n4.0\n\n\nCLion\n2025.2\n\n\n補足：\n\nUbuntu やその他のディストリビューションを使用している場合も問題ありません！本シリーズはあくまで Manjaro を例として説明しています（注：macOS はサポート対象外です）。\n\nC++ の文法規則に不慣れな場合は、まず C++ チュートリアル をお読みください。本シリーズでは少なくとも OOP の継承に関する知識が必要です。\n\n\ngtkmm のインストールManjaro での gtkmm のインストールは非常に簡単で、次の1行のコマンドを実行するだけです：\nsudo pacman -S gtkmm-4.0\n\nその他のディストリビューションでの gtkmm のインストールコマンドは以下の通りです：\nDebianFedorasudo apt install libgtkmm-4.0-devsudo dnf install gtkmm-4.0-dev\n\n一部の Linux ディストリビューションでは、対応する名称やインストールされるパッケージのバージョンが異なる場合があります。\n例えば、Arch Linux 系のディストリビューションでは、このパッケージには gtkmm と gtkmm-4.0 の 2 つのバージョンがあり、これらが指す gtkmm のバージョンは異なります。これは依存関係のバージョンを比較することで確認できます。\n\n\n一般的に、ディストリビューションが提供するパッケージマネージャーは依存関係を自動的にインストールします。比較の参考として、以下にいくつかの例を示します：\n\n最初のプロジェクトコード実装任意のコードエディタ（ここでは CLion を使用していますが、他のエディタでも構いません）を開き、hello.cpp という名前のソースファイルを作成し、以下の内容を入力（またはコピー＆ペースト）します：\n// It&#x27;s OK if you want some other cool names// This depends on you!#include &lt;gtkmm.h&gt;#include &lt;iostream&gt;// Custom GTK Window Class.class CustomGTKWindow : public Gtk::Window &#123;public:    CustomGTKWindow(); // Constructor&#125;;CustomGTKWindow::CustomGTKWindow() &#123;    set_title(&quot;Hello World&quot;); // set default title    set_default_size(800, 600); // set height and width of the window&#125;// As you can see this one is much simpler than WinMain and even Qt.int main(int argc, char *argv[]) &#123;    auto lang = &quot;C++&quot;;    std::cout &lt;&lt; &quot;Hello and welcome to &quot; &lt;&lt; lang &lt;&lt; &quot;!\\n&quot;;    auto app = Gtk::Application::create(&quot;org.gtkmm.examples.hello_world&quot;);    return app-&gt;make_window_and_run&lt;CustomGTKWindow&gt;(argc, argv);&#125;\n\n（元のチュートリアルではソースファイルの拡張子として .cc を使用しています。.cc は Linux&#x2F;UNIX システムで広く使用される C++ ソースファイル形式であり、これらのシステム向けに最適化されています。しかしここではより広範な互換性を考慮し、従来通りの .cpp 拡張子を採用します。）\nIDE 内で以下のエラーが表示された場合：\n\n同一ディレクトリ内の CMakeLists.txt を開き、内容を以下のコードスニペットに修正してください：\ncmake_minimum_required(VERSION 4.0) # change if there is a newer versionproject(hello_world) # replace it with your nameset(CMAKE_CXX_STANDARD 20) # use your own C++ standard, but make sure no earlier than C++ 17find_package(PkgConfig)pkg_check_modules(GTKMM gtkmm-4.0) # Not gtkmm-3.0!include_directories($&#123;GTKMM_INCLUDE_DIRS&#125;)link_directories($&#123;GTKMM_LIBRARY_DIRS&#125;)# set(SOURCE_FILES main.cpp MainWindow.cpp MainWindow.h)add_executable(hello_world main.cpp) # replace it with your nametarget_link_libraries($&#123;CMAKE_PROJECT_NAME&#125; $&#123;GTKMM_LIBRARIES&#125;)\n\nその後、IDE を再起動してください。問題が解決されるはずです。\n詳細は以下のリンクを参照してください：StackOverflow\n（自動翻訳が必要になる場合があります）\n\n\n結果と解説次に、プログラムをコンパイルして実行します。得られる結果は以下のようなものになるはずです：\n\n（GNOMEデスクトップ環境を使用している場合、スタイルはAdwaitaに似ているはずです）\nこれは、現時点でウィンドウタイトルを追加し、幅と高さを設定しただけだからです。まずこのコードの意味を見てみましょう：\n#include &lt;gtkmm.h&gt;\n\nこれはgtkmm.hライブラリをインクルードすることを示しています。gtkmmで構築するアプリケーションには必須です。ただし厳密に言えば、このヘッダーファイルを直接使用するのは好ましくありません——約 1MB ものサイズがあるからです！明らかにコンパイル速度を低下させます。\n次にコードの主要部分であるCustomGTKWindowクラスを見てみましょう。\n// Custom GTK Window Class.class CustomGTKWindow : public Gtk::Window &#123;public:    CustomGTKWindow(); // Constructor&#125;;CustomGTKWindow::CustomGTKWindow() &#123;    set_title(&quot;Hello World&quot;); // set default title    set_default_size(800, 600); // set height and width of the window&#125;\n\n同様に、このクラスも必須です。名前空間（stdと同等の効果を持つものと理解できます）Gtkで定義されたクラスWindowを継承し、コンストラクタを持つ必要があります（デストラクタは省略可）。以下のコンストラクタ実装部分は、ウィンドウ初期化時の基本設定コードを詳細に示しています。関数の動作は直感的で理解しやすいので、詳細な説明は省略します。\n最後に、main関数内で：\nauto app = Gtk::Application::create(「org.gtkmm.examples.hello_world」);return app-&gt;make_window_and_run&lt;CustomGTKWindow&gt;(argc, argv);\n\nこれらはウィンドウオブジェクトを作成・初期化する役割を担い、この過程でクラスのコンストラクタが呼び出されます。\nより詳細に説明すると（機械翻訳を修正）：\nプログラムはまず、Glib::RefPtr スマートポインタ（C++11で導入された新機能で、従来のポインタよりメモリ安全性に優れる）内に格納される Gtk::Application オブジェクトを作成します。create()メソッドはgtkmmを初期化します。次に、プログラムはウィンドウを作成・表示し、gtkmmのメイン処理ループ（これはtkinterと似ています！）に入ります。このループはウィンドウが閉じられると終了します。その後、main()関数は適切な成功またはエラーコードを返します。コマンドラインからプログラムを実行した場合、argcとargv引数が追加引数としてアプリケーションに渡されます。なお、make_window_and_run() の呼び出し時にはこれらの引数がチェックされますが、本日作成したシンプルなアプリケーションでは使用しません。\nまとめここまでで、最初のステップであるシンプルな gtkmm アプリケーションの作成に成功しました。完全なアプリケーションの開発は容易ではありませんが、少なくとも決定的な一歩を踏み出しました。さて、少し休憩しましょう！\n参考文献gtkmm Tutorial Chapter 2: Installation\ngtkmm Tutorial Chapter 3: Simple Example\n","categories":["Linux","C++","gtkmm"],"tags":["Linux","C++","gtkmm"]}]