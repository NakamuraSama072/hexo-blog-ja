[{"title":"2025-8-9 v1.0 Changelog","url":"/2025/08/09/first-blog/","content":"これは自サイト開設以来の最初のブログ記事です。サイト構築プロセスは大変で、途中で何度もトラブルが発生したため、ここではサイトの内容と遭遇した困難について簡単に説明し、一時的なサイトテストとして扱います。\n以降、各メジャーバージョンの更新後は、新機能、バグ修正、および詳細な最適化を説明する Changelog を公開します。\n新機能&#x2F;What’s New新機能&#x2F;New Features\nHexo 7.3.0 でブログのフレームワークを構築し、Redefine 2.8.5 をテーマとして使用しています。\n\n\n\n「カテゴリ」「リンク集」「タグ」ページを追加し、ブログコンテンツの検索や参照する他のブログサイトのリスト表示を容易にしました。句読点について聞かないでください\n\n\nバグ修正&#x2F;Bug Fix\nFirefox でのウェブページレンダリング異常エラーを修正しました\n\n「リンク」サブメニュー内でリンクを開いた際に 404 エラーが表示される問題を修正\n\n\nブログについてこのブログは何のためのものですか？ウェブサイトの上部バナーに表示されているように、「Linux and You」。したがって、このブログは主に Linux に関する内容を中心に、C/C++ や Python などの記事も含まれる可能性があります。\nこのブログはどのように構築したのですか？最初は ClawCloud のクラウドサービスを利用していました（価格が非常に魅力的だったため、Github の既存ユーザーには $5 の無料クレジットが付与されるため）。しかし、2日後、ブログファイルが格納されているポッドが常に Pending 状態になり、再起動を何度試しても改善されなかったため、怒りに任せてすべてのリソースを削除しました。\n複数のクラウドサービスプロバイダーを比較した結果、Azure と AWS は費用が高額で、インターフェースも操作が難しいことが分かりました。Google は費用が比較的低額ですが、潜在的なプライバシー問題があります。\n最終的に、Github を検討することにしました。Vercel が一部の地域でアクセス禁止されているため、Github と Netlify を組み合わせた方法でデプロイし、現在まで特に問題はありません。\nウェブサイト構築時に遭遇した問題は何ですか？「エラー修正」と上記で述べた問題の他に、以下の問題が発生しました：\n\nブランチの入力ミス。初期ブランチは main でしたが、私は master と間違えて入力しました（後に削除しました）。これにより、VSCode 内の Git の master ブランチが幽霊のように消えず、最終的にリポジトリを削除して最初からやり直す羽目になりました。（幸い、まだ設定は行っていませんでした）\n\n中日韩文字の文字化けやレンダリング異常。調べた結果、VSCode が GBK ではなく UTF-8 エンコードを使用していたためでした。\n\n\nその他の minor な問題や不可抗力要因（例えば授業など）は、ここでは詳細に説明しません。\nブログはどのような更新計画を採用するのでしょうか？ブログは Debian や Ubuntu のような安定版更新戦略を採用し、ロールイング更新は行いません。ロールイング更新を採用した場合、以下の問題が発生する可能性があります：\n\nGit のコミットが過度に頻繁になり、バージョン履歴が混乱し、管理が困難になります。\n\n新バージョンの機能決定が困難。継続的な小規模更新では明確な段階的目標が欠如する可能性があります。\n\n時間問題。頻繁な更新はメンテナンスコストを増大させますが、安定版は更新ペースとコンテンツ品質のバランスを適切に保てます。\n\n\nしたがって、ブログは不定期（ローリング更新のような頻度ではなく）にテスト済みで完成されたバージョンをリリースし、各更新で安定した体験を提供します。\nブログ内の記事には、注意や説明のセクションはありますか？あります。内容の程度に応じて、以下の3種類に分類されます：\n\n説明&#x2F;ヒント\n\n現在の内容に対する補足説明または関連情報のヒントを示します。\nCinnamon デスクトップ環境は、実際は GNOME 3 の分岐です。\n\n\n\n注意\n\n現在の環境下で推奨（強制ではない）される操作、または注意が必要な事項を示します。\nC&#x2F;C++ コンパイラは実行時チェックを行わないため、配列の越境やスタックオーバーフローなどの問題が発生するとプログラムが強制終了します。\n\n\n\n禁止\n\n現在の環境下で必須（強制）または絶対禁止の操作、または特定の操作がシステムやハードウェアに不可逆な損害を引き起こす可能性があることを示します。\n場合によっては、この部分のコンテンツがまだ作成中であり、一時的にアクセスできないことを示すためにも使用されます。\nハードディスクのフォーマットは、対象のハードディスク上のすべてのパーティションのデータを消去します！！\n\n\n以降の新しい機能\n 「概要」ページを追加\n 底部におすすめ記事セクションを追加し、迅速な移動を可能に\n ナビゲーションバーの内容を再整理\n コメント機能を追加 （現在計画なし）\n\n","categories":["changelog"],"tags":["changelog"]},{"title":"Debian 13 アップグレードガイド","url":"/2025/08/11/debian-13/","content":"This site is translated by DeepL and might not have the original taste of Japanese.\n\n\n2025年8月9日、待望の Debian 13 Trixie がついに「待望のデビュー」を果たしました。6.12 LTS カーネル、GNOME 48、そしてほぼ最新バージョンに更新されたソフトウェアパッケージを携えて登場しました。これにより、Debian は安定性における従来の評判を維持しつつ、ハードウェアサポート、パフォーマンス最適化、デスクトップ体験の面で大きな進歩を遂げました。多くの開発者、サーバー管理者、デスクトップユーザーにとって、今回のアップグレードはより良いハードウェア互換性、より長いセキュリティメンテナンス期間、そして新たな機能の探索が可能になることを意味します。\nこの記事では、Debian 12 Bookworm から Debian 13 Trixie へのスムーズなアップグレード方法について詳細に解説し、新機能を楽しむ一方でリスクを最小限に抑えるためのポイントを説明します。\n前提条件アップグレードを行う前に、現在のシステムが以下の条件を満たしていることを確認してください：\n\n最低 5 GB の空きハードディスク容量\n少なくとも 512 MB のメモリ\namd64 や arm64 など、公式にサポートされているアーキテクチャの CPU\n安定したネットワーク接続\n\nDebian 12 をまだインストールしていない場合は、この記事をスキップして直接 Debian 13 をインストールしてください。\n\nDebian 13 Trixie 以降、i386（32ビット）アーキテクチャは公式にサポートされなくなりました。i386 アーキテクチャを継続して使用する必要があるユーザーは、他の i386 をサポートする Linux ディストリビューションを使用するか、今後のアップグレードを行わないことを検討してください。\n\nアップグレードプロセス全体はカーネルの更新を含むため、更新プロセスが中断されるとシステムが起動できなくなったり、正常に動作しなくなったりする可能性があります。また、システムのスリープ機能を必ず無効化してください。そうしないと、更新が不完全になったり、直接中断されたりする可能性があります。\n\n更新を行う前に、サーバーとのネットワーク接続が正常であることを確認してください。無線ネットワークの品質が非常に悪い場合は、別の場所に移って再度試してください。条件が許す場合は、イーサネットまたは有線接続の使用を推奨します。以下のコマンドを使用して、サーバーとの接続性をテストできます：\n\n\nping www.debian.org # Ctrl + C を押して中止\n\nアップグレード前の準備重要なデータのバックアップ（任意）このステップでは、rsync、tar、または BorgBackup などのツールを使用する必要があります。もちろん、ext4 ファイルシステムを使用している場合は、timeshift も利用可能です。具体的な操作手順については、公式マニュアルをご参照ください。\nソフトウェアソースの更新sudo apt update を実行してソフトウェアソースを更新し、新しいソフトウェアバージョンを取得します。\nDebian 13 以降、ソフトウェアソース設定ファイルは新しい DEB822 形式に全面的に移行され、パスが元の /etc/apt/sources.list から /etc/apt/sources.list.d/debian.sources に変更されます。この変更は、皆様がご存知の Ubuntu 24.04 LTS 以降のバージョンで既に実施されています。\n\n\n\nDebian 12 は以下のコマンドをネイティブでサポートしていません：sudo apt modernize-sourcesDebian 12 でこのコマンドを使用してソフトウェアソース設定ファイルのフォーマットを変更するよう指示するチュートリアルは、誤った情報を提供するものです！\n\n\nこの操作が完了した後、以下のエラーメッセージが表示された場合：\n\nこれは、現在の Debian 12 のソフトウェアソース設定ファイルがまだ Bookworm のものを使用していることを示しています（ソフトウェアソースリポジトリから返される情報によると、Bookworm は現在旧安定版となっていますが、システムは依然としてそれを現在の安定版と認識しています）。この問題を解決するには、sed を使用してテキストを自動的に置換する必要があります（sudo 権限が必要です）：\nsed -i &quot;s/bookworm/trixie/g&quot; /etc/apt/sources.list# DEB822 形式の構成ファイルを使用している場合sed -i &quot;s/bookworm/trixie/g&quot; /etc/apt/sources.list.d/*.listsed -i &quot;s/bookworm/trixie/g&quot; /etc/apt/sources.list.d/*.sources\n後者の2つの提示 no matches found: xxx は、一時的に置き換える必要はありません。\n\n\nこの手順では、/etc/apt/sources.list、/etc/apt/sources.list.d/*.list、および /etc/apt/sources.list.d/*.sources 設定ファイル内の bookworm に一致するすべての文字列を trixie に置き換えます。これにより、現在のバージョンのソフトウェアリポジトリを使用できるようになります。\n別の方法は手動編集です：\nsudo apt edit-sources\n\nこの手順は、vim や nano などのファイルエディターを使用して行うことも可能です。\n事前に伝統的な設定ファイルを新しい DEB822 形式に手動で置き換えた場合、/etc/apt/sources.list を安全に削除できます。\n\n\nシステム更新一部のソフトウェアパッケージのアップグレード新しいソフトウェアパッケージをインストールせずに、一部のソフトウェアパッケージをアップグレードします：\nsudo apt updatesudo apt upgrade --without-new-pkgs\n\nこの手順ではLinuxカーネルのバージョンは更新されません（Debian 12のデフォルトカーネルバージョンがどれほど古いかに注目してください）。この目的は、依存関係の問題を確認するためです。問題がある場合は、sudo apt --fix-broken installを実行して迅速に解決してください。\n\n\nカーネルのアップグレード次に、システム全体を大規模にアップグレードします：\nsudo apt full-upgrade -y\n\nこのステップではカーネルのアップグレードが必要のため、時間がかかりますので、一時的に休憩を取っても構いません。\nアップグレード中に以下の画面が表示される場合があります：\n\nここではYesを選択し、更新プロセスを続行します。\n更新後の操作不要なパッケージの削除ターミナルがaptの情報を表示しなくなり（コマンド入力を待つ状態になる）、ソフトウェアソースをクリーンアップし、不要なパッケージを削除します：\nsudo apt autoremove -y # 不要なパッケージを削除（--purgeオプションを追加可）sudo apt autoclean # ソフトウェアソースをクリーンアップ\n\n現在の更新後のバージョンを確認するカーネルバージョンとシステムバージョンを確認してください：\nuname -r # カーネルバージョンlsb_release -a # システムバージョン# または cat /etc/os-release を実行\n\n出力は以下のようなものになるはずです：\n\n新バージョンを体験開始システムを再起動します：\nsudo reboot\n\nインターフェースのテーマは以下のような画像と類似しているはずです：\n\n\n（リソース節約のため、Xfce デスクトップ環境を使用しています）\nこれで、Debian 13 Trixie へのアップグレード作業は正式に完了しました。\n次期 Debian 安定版についてDebian 14 のコードネームは正式に「forky」と決定されましたが、現在、採用される LTS カーネルやソフトウェアパッケージのバージョンなどに関する詳細は不明です。ただし、以下の点は確定しています：\n\nLTS 戦略の継続\n\n以前のバージョン同様、Debian 14 は少なくとも5年間のセキュリティ更新サイクルを提供し、さらにハードウェア互換性を向上させるため、新しいカーネルのマイナーバージョンを導入する可能性があります。\n\n新しいハードウェアアーキテクチャのサポート\n\n次世代の x86_64-v3 命令セットや ARM プラットフォーム上の最新 SoC に対するサポートを強化し、デスクトップとサーバー機器のパフォーマンス向上を実現します。\n\nデスクトップ環境のバージョンアップグレード\n\nGNOME、KDE Plasma、Xfce などの主要なデスクトップ環境は、上流の主要バージョンに追随し、新しい機能とインターフェースの改善をもたらします。  \n\nソフトウェアパッケージの整理と置き換え\n\nメンテナンスが終了したまたはセキュリティリスクの高いソフトウェアパッケージは削除され、より現代的な代替案が導入されます。\n\nインストールと設定体験の最適化\n\nCalamares、Debian Installer などのインストールツールはさらに改善されます（現在、教育版、天文版など他のバージョンが追加されています）。これにより、新規ユーザーのインストール障壁を低下させ、ユーザー層の多様化を促進します。\n参考https://fullmetalbrackets.com/blog/upgrade-debian-12-bookworm-debian-13-trixie/\nhttps://stackoverflow.com/questions/68802802/repository-http-security-debian-org-debian-security-buster-updates-inrelease\n（元の言語は英語です。可能な場合は、自動翻訳をご利用ください）\n","categories":["Linux","Debian"],"tags":["Linux","Debian"]},{"title":"gtkmm チュートリアル（1）── gtkmm のインストールと使い方","url":"/2025/08/23/gtkmm-note1-installation/","content":"GTK は、GNOME 公式が提供する GNOME デスクトップ環境アプリケーション開発キットです。イベント駆動型に基づいており、実行時にはアプリケーション内で発生するイベント（マウスクリックやウィンドウサイズ変更など）を監視し、アプリケーション内のコンポーネントに情報を伝達します。\nGTK は C、JavaScript、Python、Rust など複数の言語をサポートしています。しかし、ウェブ上で公開されているサンプルコードを見ると、私が比較的慣れ親しんでいる C 言語の実装は複雑であり、Python は比較的シンプルですが、本稿で扱う範囲ではありません。そこで、ここでは構文スタイルが C++ に近い拡張パッケージである gtkmm を、このシリーズの開発ツールキットとして採用します。\n始める前に本シリーズで使用するデフォルトの開発環境は以下の通りです：\n\n\n\n名前\nバージョン\n\n\n\nManjaro\n25\n\n\ngtkmm\n4.0\n\n\nCLion\n2025.2\n\n\n補足：\n\nUbuntu やその他のディストリビューションを使用している場合も問題ありません！本シリーズはあくまで Manjaro を例として説明しています（注：macOS はサポート対象外です）。\n\nC++ の文法規則に不慣れな場合は、まず C++ チュートリアル をお読みください。本シリーズでは少なくとも OOP の継承に関する知識が必要です。\n\n\ngtkmm のインストールManjaro での gtkmm のインストールは非常に簡単で、次の1行のコマンドを実行するだけです：\nsudo pacman -S gtkmm-4.0\n\nその他のディストリビューションでの gtkmm のインストールコマンドは以下の通りです：\nDebianFedorasudo apt install libgtkmm-4.0-devsudo dnf install gtkmm-4.0-dev\n\n一部の Linux ディストリビューションでは、対応する名称やインストールされるパッケージのバージョンが異なる場合があります。\n例えば、Arch Linux 系のディストリビューションでは、このパッケージには gtkmm と gtkmm-4.0 の 2 つのバージョンがあり、これらが指す gtkmm のバージョンは異なります。これは依存関係のバージョンを比較することで確認できます。\n\n\n一般的に、ディストリビューションが提供するパッケージマネージャーは依存関係を自動的にインストールします。比較の参考として、以下にいくつかの例を示します：\n\n最初のプロジェクトコード実装任意のコードエディタ（ここでは CLion を使用していますが、他のエディタでも構いません）を開き、main.cpp という名前のソースファイルを作成し、以下の内容を入力（またはコピー＆ペースト）します：\n// It&#x27;s OK if you want some other cool names// This depends on you!#include &lt;gtkmm.h&gt;#include &lt;iostream&gt;// Custom GTK Window Class.class CustomGTKWindow : public Gtk::Window &#123;public:    CustomGTKWindow(); // Constructor&#125;;CustomGTKWindow::CustomGTKWindow() &#123;    set_title(&quot;Hello World&quot;); // set default title    set_default_size(800, 600); // set height and width of the window&#125;// As you can see this one is much simpler than WinMain and even Qt.int main(int argc, char *argv[]) &#123;    auto lang = &quot;C++&quot;;    std::cout &lt;&lt; &quot;Hello and welcome to &quot; &lt;&lt; lang &lt;&lt; &quot;!\\n&quot;;    auto app = Gtk::Application::create(&quot;org.gtkmm.examples.hello_world&quot;);    return app-&gt;make_window_and_run&lt;CustomGTKWindow&gt;(argc, argv);&#125;\n\n（元のチュートリアルではソースファイルの拡張子として .cc を使用しています。.cc は Linux&#x2F;UNIX システムで広く使用される C++ ソースファイル形式であり、これらのシステム向けに最適化されています。しかしここではより広範な互換性を考慮し、従来通りの .cpp 拡張子を採用します。）\nIDE 内で以下のエラーが表示された場合：\n\n同一ディレクトリ内の CMakeLists.txt を開き、内容を以下のコードスニペットに修正してください：\ncmake_minimum_required(VERSION 4.0) # change if there is a newer versionproject(hello_world) # replace it with your nameset(CMAKE_CXX_STANDARD 20) # use your own C++ standard, but make sure no earlier than C++ 17find_package(PkgConfig)pkg_check_modules(GTKMM gtkmm-4.0) # Not gtkmm-3.0!include_directories($&#123;GTKMM_INCLUDE_DIRS&#125;)link_directories($&#123;GTKMM_LIBRARY_DIRS&#125;)# set(SOURCE_FILES main.cpp MainWindow.cpp MainWindow.h)add_executable(hello_world main.cpp) # replace it with your nametarget_link_libraries($&#123;CMAKE_PROJECT_NAME&#125; $&#123;GTKMM_LIBRARIES&#125;)\n\nその後、IDE を再起動してください。問題が解決されるはずです。\n詳細は以下のリンクを参照してください：StackOverflow\n（自動翻訳が必要になる場合があります）\n\n\n結果と解説次に、プログラムをコンパイルして実行します。得られる結果は以下のようなものになるはずです：\n\n（GNOMEデスクトップ環境を使用している場合、スタイルはAdwaitaに似ているはずです）\nこれは、現時点でウィンドウタイトルを追加し、幅と高さを設定しただけだからです。まずこのコードの意味を見てみましょう：\n#include &lt;gtkmm.h&gt;\n\nこれはgtkmm.hライブラリをインクルードすることを示しています。gtkmmで構築するアプリケーションには必須です。ただし厳密に言えば、このヘッダーファイルを直接使用するのは好ましくありません——約 1MB ものサイズがあるからです！明らかにコンパイル速度を低下させます。\n次にコードの主要部分であるCustomGTKWindowクラスを見てみましょう。\n// Custom GTK Window Class.class CustomGTKWindow : public Gtk::Window &#123;public:    CustomGTKWindow(); // Constructor&#125;;CustomGTKWindow::CustomGTKWindow() &#123;    set_title(&quot;Hello World&quot;); // set default title    set_default_size(800, 600); // set height and width of the window&#125;\n\n同様に、このクラスも必須です。名前空間（stdと同等の効果を持つものと理解できます）Gtkで定義されたクラスWindowを継承し、コンストラクタを持つ必要があります（デストラクタは省略可）。以下のコンストラクタ実装部分は、ウィンドウ初期化時の基本設定コードを詳細に示しています。関数の動作は直感的で理解しやすいので、詳細な説明は省略します。\n最後に、main関数内で：\nauto app = Gtk::Application::create(「org.gtkmm.examples.hello_world」);return app-&gt;make_window_and_run&lt;CustomGTKWindow&gt;(argc, argv);\n\nこれらはウィンドウオブジェクトを作成・初期化する役割を担い、この過程でクラスのコンストラクタが呼び出されます。\nより詳細に説明すると（機械翻訳を修正）：\nプログラムはまず、Glib::RefPtr スマートポインタ（C++11で導入された新機能で、従来のポインタよりメモリ安全性に優れる）内に格納される Gtk::Application オブジェクトを作成します。create()メソッドはgtkmmを初期化します。次に、プログラムはウィンドウを作成・表示し、gtkmmのメイン処理ループ（これはtkinterと似ています！）に入ります。このループはウィンドウが閉じられると終了します。その後、main()関数は適切な成功またはエラーコードを返します。コマンドラインからプログラムを実行した場合、argcとargv引数が追加引数としてアプリケーションに渡されます。なお、make_window_and_run() の呼び出し時にはこれらの引数がチェックされますが、本日作成したシンプルなアプリケーションでは使用しません。\nまとめここまでで、最初のステップであるシンプルな gtkmm アプリケーションの作成に成功しました。完全なアプリケーションの開発は容易ではありませんが、少なくとも決定的な一歩を踏み出しました。さて、少し休憩しましょう！\n参考文献gtkmm Tutorial Chapter 2: Installation\ngtkmm Tutorial Chapter 3: Simple Example\n","categories":["Linux","C++","gtkmm"],"tags":["Linux","C++","gtkmm"]},{"title":"このサイトがHaloへ移行する旨のお知らせ","url":"/2025/11/05/migration-on-the-way/","content":"いつも当ブログをご愛読いただき、誠にありがとうございます。より安定し、高速な閲覧体験を提供するため、そして私自身の技術的・時間的な都合も考慮し、本サイトのフレームワークを現在の Hexo から Halo へと移行する予定です。\n\n移行の主な理由1. より充実した機能と管理体験を求めてHexo は静的ブログとして非常に軽量で優れていますが、コンテンツ管理やインタラクション機能の面では制約があります。一方、Halo は強力な管理画面を備えており、より直感的なコンテンツ編集や多言語管理をサポートしています。これにより、私はより創作そのものに集中できるようになります。\n2. サイト性能のさらなる向上Halo はモダンな動的ブログシステムとして、高速な応答性を保ちつつ、Hexo よりも豊富な標準機能を提供します。これにより、今後の機能拡張にも柔軟に対応できる基盤を整えることができます。\n\n「なぜ他のフレームワークではないのか？」1. 技術スタックと運用方針の整理以前公開した changelog でも触れましたが、英語版サイトでは WordPress を採用しており、現在移行作業を進めています。技術スタックや運用方式の重複を避けるため、日本語（および中国語）サイトでは、よりシンプルで軽量な新しいアプローチを試みたいと考えています。\n2. Astro についてAstro は確かに高いパフォーマンスを誇る優れたフレームワークです。しかし、開発には相応のフロントエンド知識と工数が求められます。私のように主に C&#x2F;C++ を扱う開発者にとっては、ややハードルが高いのが現状です。そのため、Hexo 時代のように複雑な構築・保守作業に時間を取られるよりも、創作活動そのものに集中できる環境を整えたいと考えています。\n\n今後について移行期間中は、一時的にサイトへアクセスしづらい状況が発生する可能性があります。ご不便をおかけいたしますが、何卒ご理解のほどよろしくお願いいたします。  \n新しいサイトでは、これまでのコンテンツやリンクの大部分を引き継ぎ、changelog は専用のアーカイブページとしてまとめる予定です。より快適でスムーズな閲覧体験をお届けできるよう努めてまいります。\n\n今後とも変わらぬご支援のほど、心よりお願い申し上げます。\n","categories":["changelog"],"tags":["changelog"]},{"title":"gtkmm チュートリアル（2）—— 単純なウィジェットとシグナル","url":"/2025/09/22/gtkmm-note2-widgets-and-signals/","content":"gtkmm の開発でまず登場するのが ウィジェット。これはウィンドウを作る上でなくてはならない存在です。\nただし「ウィジェット」と一言で言っても、その範囲はかなり広いんです。たとえば ボタン や チェックボックス のように直接ユーザーに見える部品もあれば、他のウィジェットを並べたり整理するためのコンテナ も含まれます。\nコンテナ系のウィジェットはそれ自体が画面に見えるわけではないので、ここでは「非表示コンポーネント」と呼んでおきましょう。役割としては、表示される部品たちを階層的にまとめて、配置や管理をしやすくしてくれる裏方さんです。\n環境によっては、こうしたウィジェットを「コントロール（control）」と呼ぶこともあります。日本語でも「UIコントロール」とか「コントロール部品」という言い方がよく使われますよね。\nそして、GTK を語る上で外せないもうひとつの要素が シグナル（signal） です。GTK はイベント駆動型のツールキットなので、この仕組みがめちゃくちゃ重要になります。\nシグナルはざっくりいうと、ボタンをクリックしたり、ダブルクリックしたり、長押ししたり、スクロールしたり──そうしたユーザー操作に応じて、部品が「反応」する仕組み のことです。\nイメージしやすいように人間の体に例えると、指先に刺激が加わったときに末梢神経を通じて信号が脳に伝わり、体が何らかの動きを返す──そんな流れに近い感じです。\n簡単サンプルで始めようスタート前に今回のサンプルでは gtkmm/button.h と gtkmm/window.h を使います。\n「全部入り」の gtkmm.h をインクルードしてしまう方法もあるんですが、正直コンパイルが遅くなるのでおすすめしません。必要なものだけを読み込むのが一番です。\nGlib::ustring ってなに？Glib::ustring は、gtkmm が用意している文字列用のデータ型です。\nパッと見は std::string とほとんど同じように使えます。じゃあ何が違うの？というと…\n実は std::string は環境によって「1文字＝最大8ビット」扱いになってしまうことがあります。日本語や中国語、韓国語のように多バイトが必要な文字を扱うと不具合のもとになりやすいんです。\nそこで登場するのが Glib::ustring。こちらは Unicode（実際には UTF-8）ベースなので、多言語対応も安心です。\nまずはシンプルなウィンドウから入門のうちは、ウィンドウクラスと main 関数をひとつのファイルにまとめて書きがちです。\nでも実際の開発では、クラス定義をヘッダファイル、実装を .cpp ファイルに分けるのが基本スタイル。main.cpp がどんどん肥大化すると、後から探すのが大変になりますからね。\nファイル名はヘッダとソースで揃える必要があるので、こんな感じの構成がおすすめです：\nxxx (Project Name) ├─include │    ├─header_a.h │    └─... │ ├─src │  ├─header_a.cpp │  └─... │ ├─tests │   ├─test_a.cpp │   └─... (Other test files/framework configurations) │ ├─... (Other files/folders) ├─.gitignore ├─main.cpp ├─CMakeLists.txt └─README.md\n\nここでは例として include/helloworld.h にクラス定義を書き、src/helloworld.cpp に実装を置きます：\n// helloworld.h#ifndef HELLOWORLD_H#define HELLOWORLD_H// In some IDEs, we may use #pragma once, and without #endif#include &lt;gtkmm/button.h&gt;#include &lt;gtkmm/window.h&gt;// Just include what you really need, like in Pythonclass HelloWorld : public Gtk::Window &#123;public:    HelloWorld();    ~HelloWorld() override;protected:    // Signal handlers:    void on_button_clicked();    // Member widgets:    Gtk::Button m_button;&#125;;#endif // HELLOWORLD_H\n\n// helloworld.cpp#include &quot;../include/helloworld.h&quot;#include &lt;iostream&gt;// Create a new button with label &quot;Hello World&quot;HelloWorld::HelloWorld(): m_button(&quot;Hello World&quot;) &#123;    // set the margin around the button    m_button.set_margin(10);    // packs the button into the window    set_child(m_button);    set_title(&quot;Hello World&quot;);    set_default_size(200, 120);&#125;// Destructor (Do nothing by default)HelloWorld::~HelloWorld() &#123;&#125;// This must be defined for binding event to the buttonvoid HelloWorld::on_button_clicked() &#123;    std::cout &lt;&lt; &quot;Hello World\\n&quot;;&#125;;\n\nCMakeLists.txt の設定も忘れずに（CLion なら自動で更新してくれることもあります）。\nボタンにシグナルをつなげるGTK では「シグナル」をハンドラ関数につなぐのが基本操作です。使うのは connect 関数。\nイメージはこんな感じ：\n// IMPORTANT: bind the event to the buttonm_button.signal_clicked().connect(sigc::mem_fun(*this,    &amp;HelloWorld::on_button_clicked));\n\nここで signal_clicked() は「ボタンがクリックされたときに発生するシグナル」。\nで、後ろの sigc::mem_fun は「このオブジェクトの、この関数を呼んでね」というお約束です。公式の説明は難しく見えますが、覚え方はシンプル：\n👉 *this ＋ 呼びたいメンバ関数名（括弧は付けない）\nたとえば on_button_clicked という関数を呼びたいなら：\nbutton.signal_clicked().connect(sigc::mem_fun(*this, &amp;HelloWorld::on_button_clicked));\n\nもし connect を忘れていたり、引数を間違えていたら、ボタンを押しても完全に無反応です（コンソール出力もなし）。\nいざ実行！最後に main.cpp を仕上げます：\n#include &lt;gtkmm/application.h&gt;#include &quot;include/helloworld.h&quot;// As you can see this one is much simpler than WinMain and even Qt.int main(int argc, char *argv[]) &#123;    auto app = Gtk::Application::create(&quot;org.gtkmm.examples.hello_world&quot;);    return app-&gt;make_window_and_run&lt;HelloWorld&gt;(argc, argv);&#125;\n\nビルドして実行すれば、じゃーん！こんなウィンドウが立ち上がるはずです：\n\nボタンをクリックしてみようボタンをクリックすると、コンソールに情報が表示されます：\n\nここで表示される MESA-INTEL の警告は無視して大丈夫です。これは単に開発者がまだ一部の機能を実装していないだけです。\nただし、もし次のような警告が出てきたら注意してください：\nGtk-WARNING **: 23:40:39.776: Unknown key gtk-modules in /home/$USER/.config/gtk-4.0/settings.ini\n\nこれは、gtkmm をインストールした際に、GTK 3 で使われていた古い設定が GTK 4 の設定ファイルに混入してしまったのが原因です。\n解決方法は簡単で、settings.ini を開いて次の行を削除、またはコメントアウトします：\n#gtk-modules=colorreload-gtk-module:window-decorations-gtk-module\n\nこれで再度コンパイル・実行すれば、警告は出なくなります。\nもしボタンを一度クリックして「Hello World」と表示されたなら、もう大部分はクリアです。おめでとうございます！\n複合的な使い方次は少しステップアップして、ボタンをクリックすると現在の日時・ログインユーザー名・利用している端末の名前（tty）をファイルに書き出す簡単なアプリを作ってみましょう。\n背景知識日時の取得C++ では chrono と ctime を使うことで現在の時間と日付を取得できます。例：\n// get current time point (not a string of time)auto now = std::chrono::system_clock::now();// convert time_point type to time_tstd::time_t t = std::chrono::system_clock::to_time_t(now);// convert time_t to stringstd::string time_str = std::ctime(&amp;t);\n\nつまり、日時を出力するには最低3行必要です。\nログインユーザー名の取得これは環境変数を利用して std::getenv で取得できます。cstdlib をインクルードする必要があります。\nconst char* username = std::getenv(&quot;USER&quot;);\n\nより詳しい情報が欲しい場合は getpwuid(getuid())（pwd.h が必要）を使う方法もあります。\n端末パス（tty）の取得ttyname(STDIN_FILENO) を使うと現在の端末パス（例：/dev/pts/0）を取得できます。\nconst char* tty = ttyname(STDIN_FILENO);\n\nこれを利用するには unistd.h をインクルードしてください。\nファイル入出力C++ には fstream という標準のファイル入出力ライブラリがあります。使い方はとてもシンプルで、C++ の標準入出力に慣れていれば問題ありません。\n例：\n// Method 1: determine file name when defining the file I/O streamstd::ifstream fin_eg1(&quot;example.txt&quot;);std::string str;fin_eg1 &gt;&gt; str;fin_eg1.close();// Method 2: determine file name later (recommended)std::ifstream fin_eg2;fin_eg2.open(&quot;example.txt&quot;);// 以下は同じfin_eg2.close();\n\nstd::ofstream の書き方もほとんど同じなので割愛します。\n実装手順まず userinfo.h を用意します：\n#ifndef USERINFO_H#define USERINFO_H// In some IDEs, this could be #pragma once#include &lt;gtkmm/button.h&gt;#include &lt;gtkmm/window.h&gt;class CustomUserInfoWindow: public Gtk::Window &#123;public:    CustomUserInfoWindow();    ~CustomUserInfoWindow() override;protected:    // Signal Handlers (like on_button_clicked)    void export_userinfo();    // Member Widgets    Gtk::Button prompt_button;&#125;;#endif //USERINFO_H\n\n次に userinfo.cpp に実装を書きます：\nCustomUserInfoWindow::CustomUserInfoWindow():    prompt_button(&quot;Get User Info&quot;) &#123;    // set the margin around the button    prompt_button.set_margin(10);    // IMPORTANT: bind the event to the button    prompt_button.signal_clicked().connect(sigc::mem_fun(*this,        &amp;CustomUserInfoWindow::export_userinfo));    // packs the button into the window    set_child(prompt_button);    set_title(&quot;Hello World&quot;);    set_default_size(200, 120);&#125;CustomUserInfoWindow::~CustomUserInfoWindow() &#123;&#125;void CustomUserInfoWindow::export_userinfo() &#123;    // get current time point (not a string of time)    auto now = std::chrono::system_clock::now();    // convert time_point type to time_t    std::time_t t = std::chrono::system_clock::to_time_t(now);    // convert time_t to string    std::string time_str = std::ctime(&amp;t);    // get current username    const char* username = getenv(&quot;USER&quot;);    // not username; please use linux env vars    // terminal name (tty)    const char* tty_name = ttyname(STDIN_FILENO);    // make output    std::ofstream fout(&quot;user_info.txt&quot;, std::ios::app);    fout &lt;&lt; &quot;----------------------------------\\n&quot;; // dividing line    fout &lt;&lt; &quot;date: &quot; &lt;&lt; time_str;    fout &lt;&lt; &quot;username: &quot; &lt;&lt; username &lt;&lt; &quot;\\n&quot;;    fout &lt;&lt; &quot;tty_name: &quot; &lt;&lt; tty_name &lt;&lt; &quot;\\n&quot;;    fout &lt;&lt; &quot;----------------------------------\\n&quot;; // dividing line    std::cout &lt;&lt; &quot;User info exported!\\n&quot;;    fout.close();&#125;\n\n最後に main.cpp を仕上げます：\n#include &quot;include/userinfo.h&quot;#include &lt;gtkmm/application.h&gt;int main(int argc, char *argv[]) &#123;    auto app = Gtk::Application::create(&quot;org.gtkmm.examples.widgets-integrated&quot;);    return app-&gt;make_window_and_run&lt;CustomUserInfoWindow&gt;(argc, argv);&#125;\n\n実行結果ビルド＆実行すると、こんなウィンドウが出てきます：\n「Get User Info」をクリックすると、user_info.txt に以下のような内容が出力されます：\nそしてコンソールには次のメッセージ：\nこの後の内容次回は Gtk::Button をさらに掘り下げて、ToggleButton、CheckButton、RadioButton などの種類を紹介します。また、カスタムアイコンの設定やウィンドウタイトルバーを隠す方法についても解説する予定です。\n参考リンク\ngtkmm Tutorial Chapter 3. Basics: Widgets\ngtkmm Tutorial Chapter 3. Basics: Signals\ngtkmm Tutorial Chapter 3. Basis: Glib::ustring\ngtkmm Tutorial Chapter 3. Basics: Hello World in gtkmm\n\n※必要に応じて、自動翻訳サービス（例：DeepL）を利用して確認することもおすすめです。\n","categories":["Linux","C++","gtkmm"],"tags":["Linux","C++,gtkmm"]},{"title":"changelog3","url":"/2025/09/23/changelog3/","content":"新機能&#x2F;What’s New新しい特徴&#x2F;New Features\nコメント区が開放され、現在は Giscus をサポートしています。\n\n\n変更点&#x2F;Changed\nホームページの背景画像を変更しました（残念ながら出典は不明です）。\n\n\n\nクリックすると文字が現れるエフェクトを削除しました（コピーの妨げになるため）。\n\nバグ修正&#x2F;Bug Fix\n一部記事内の文法、句読点の誤りや不適切な文体を修正しました。\n\n今後導入予定&#x2F;Upcoming Features2025 年 11 月 5 日更新：ブログはまもなくHaloへ移行します。以下のコンテンツは追加を停止します。\n\n 新しいナビゲーションバー\n Element UI と Emoji\n Github Badge\n\n英語サイトに関する重要なお知らせ不可抗力の要因により、英語サイトは近日中に更新を停止します。再開時期は後日お知らせいたします。その際、WordPress フレームワークへ移行します。\n","categories":["changelog"],"tags":["changelog"]},{"title":"2025-8-18 v2.0 Changelog","url":"/2025/08/18/changelog2/","content":"長期間にわたる改修を経て、このブログサイトがついに 2.0 バージョンにアップデートされました。\n以下に具体的な説明を記載します。\n新機能&#x2F;What’s New新しい特徴&#x2F;New Features\n「概要」ページを追加しました\n\n\n\n関連記事の推薦セクションを追加しました\n\n\n\n英語と日本語のポータルサイトを追加（注：英語サイトは、中国語と日本語のサイトと異なるテーマを使用しています）\n\n\n\n注意：v1.0バージョン時点では、日本語サイトは既に展開されていましたが、当時はまだテスト段階にありました。\n変更点&#x2F;Changed\nサイトの美化と国際化対応のため、ブログのテーマを Redefine 2.8.5 から Butterfly 5.4.3 に変更しました\n\n\n修正内容&#x2F;Bug Fix\n特定の記事内に存在していた誤った内容を修正しました\nGit コミット時に変更内容がデプロイ先のウェブサイトに表示されない問題を修正しました\n新テーマ使用時に「友達」ページが開けない問題を修正しました\n\n国際化についてここで採用した方法は、言語ごとに異なるリポジトリを使用し、最終的にドロップダウンメニューのリンクで遷移させるものです。これは最善策ではありませんが、source フォルダのコンテンツをいじくり回して大量の JavaScript を追加するよりもはるかに優れています。もう一つの大きな利点は、言語ごとに異なる地域向けのテーマを指定できることで、これにより異なる国や地域（例えば欧米）の人々の好みに合わせやすくなります。\n","categories":["changelog"],"tags":["changelog"]}]